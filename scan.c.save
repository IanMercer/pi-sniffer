/*
 * bluez sniffer
 *  Sends bluetooth information to MQTT with a separate topic per device and parameter
 *  BLE/<device mac>/parameter
 *
 *  Applies a simple kalman filter to RSSI to smooth it out somewhat
 *  Sends RSSI only when it changes enough but also regularly a keep-alive
 *
 *  gcc `pkg-config --cflags glib-2.0 gio-2.0` -Wall -Wextra -o ./bin/bluez_adapter_filter ./bluez_adapter_filter.c `pkg-config --libs glib-2.0 gio-2.0`
 *
 *  See build.sh and READ.ME for further instructions
 *
 */
#include <glib.h>
#include <gio/gio.h>
#include <stdbool.h>
#include <stdio.h>
#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <net/if.h>
#include <time.h>
#include <math.h>
#include <signal.h>

char* client_id = NULL;

#include "utility.c"
#include "mqtt_send.c"
#include "kalman.c"

// delta distance x delta time threshold for sending an update
// e.g. 5m after 2s or 1m after 10s
// prevents swamping MQTT with very small changes
// but also guarantees an occasional update to indicate still alive

#define THRESHOLD 10.0

// Handle Ctrl-c
void     int_handler(int);

/*
   Structure for reporting to MQTT

   TODO: Add time_t to this struct, keep them around not clearing hash an report every five minutes
   on all still connected devices incase MQTT isn't saving values.
*/
struct Device
{
    char *name;
    char *alias;
    char *addressType;
    int32_t manufacturer;
    bool paired;
    bool connected;
    bool trusted;
    uint32_t deviceclass; // https://www.bluetooth.com/specifications/assigned-numbers/Baseband/
    uint16_t appearance;
    int manufacturer_data_hash;
    int uuids_length;             // should use a Hash instead
    time_t last_rssi;             // last time an RSSI was received. If gap > 0.5 hour, ignore initial point (dead letter post)
    struct Kalman kalman;
    time_t last_sent;
    float last_value;
    struct Kalman kalman_interval; // Tracks time between RSSI events in order to detect large gaps
    GSList * transition_to;
};


// The mac address of the wlan0 interface (every Pi has one so fairly safe to assume wlan0 exists)

static char access_point_address[6];
char controller_mac_address[13];
char hostbuffer[256];

/* SEND TO MQTT WITH ACCESS POINT MAC ADDRESS AND TIME STAMP */


GHashTable *hash = NULL;

// Free an allocated device

void device_report_free(void *object)
{
    struct Device *val = (struct Device *)object;
    g_print("FREE name '%s'\n", val->name);
    /* Free any members you need to */
    g_free(val->name);
    g_print("FREE alias '%s'\n", val->alias);
    g_free(val->alias);
    g_print("FREE value\n");
    g_free(val);
}

GDBusConnection *con;

typedef void (*method_cb_t)(GObject *, GAsyncResult *, gpointer);

static int bluez_adapter_call_method(const char *method, GVariant *param, method_cb_t method_cb)
{
    //    g_print("bluez_adapter_call_method(%s)\n", method);
    GError *error = NULL;

    g_dbus_connection_call(con,
                           "org.bluez", /* TODO Find the adapter path runtime */
                           "/org/bluez/hci0",
                           "org.bluez.Adapter1",
                           method,
                           param,
                           NULL,
                           G_DBUS_CALL_FLAGS_NONE,
                           -1,
                           NULL,
                           method_cb,
                           &error);
    if (error != NULL)
        return 1;
    return 0;
}

static void bluez_get_discovery_filter_cb(GObject *con,
                                          GAsyncResult *res,
                                          gpointer data)
{
    g_print("bluez_get_discovery_filter_cb(...)\n");
    (void)data;

    GVariant *result = NULL;
    result = g_dbus_connection_call_finish((GDBusConnection *)con, res, NULL);
    if (result == NULL)
        g_print("Unable to get result for GetDiscoveryFilter\n");

    if (result)
    {
        GVariant *child = g_variant_get_child_value(result, 0);
        pretty_print("GetDiscoveryFilter", child);
        g_variant_unref(child);
    }
    g_variant_unref(result);
}


/*
    REPORT DEVICE TO MQTT

    address if known, if not have to find it in the dictionary of passed properties
    appeared = we know this is fresh data so send RSSI and TxPower with timestamp
*/

static bool repeat = FALSE; // runs the get managed objects call just once, 15s after startup

static void report_device_disconnected_to_MQTT(char* address)
{
    if (hash == NULL) return;

    if (!g_hash_table_contains(hash, address))
        return;

    //struct Device * existing = (struct Device *)g_hash_table_lookup(hash, address);

    // Reinitialize it so next value is swallowed??
    //kalman_initialize(&existing->kalman);

    // TODO: A stable iBeacon gets disconnect events all the time - this is not useful data

    // Send a marker value to say "GONE"
    //int fake_rssi = 40 + ((float)(address[5] & 0xF) / 10.0) + ((float)(access_point_address[5] & 0x3) / 2.0);

    //send_to_mqtt_single_value(address, "rssi", -fake_rssi);

    // DON'T REMOVE VALUE FROM HASH TABLE - We get disconnected messages and then immediately reconnects
    // Remove value from hash table
    // g_hash_table_remove(hash, address);
}


static void report_device_to_MQTT(GVariant *properties, char *address, bool changed)
{
    //       g_print("report_device_to_MQTT(%s)\n", address);


    //pretty_print("report_device", properties);

    // Get address from dictionary if not already present
    GVariant *address_from_dict = g_variant_lookup_value(properties, "Address", G_VARIANT_TYPE_STRING);
    if (address_from_dict != NULL)
    {
        if (address != NULL)
        {
            g_print("ERROR found two addresses\n");
        }
        address = g_variant_dup_string(address_from_dict, NULL);
        g_variant_unref(address_from_dict);
    }

    if (address == NULL)
    {
        g_print("ERROR address is null");
        return;
    }

    // Get existing report

    if (hash == NULL)
    {
        g_print("Starting a new hash table\n");
        hash = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, device_report_free);
    }

    struct Device *existing;

    if (!g_hash_table_contains(hash, address))
    {
        existing = g_malloc0(sizeof(struct Device));
        g_hash_table_insert(hash, strdup(address), existing);

        // dummy struct filled with unmatched values
        existing->name = NULL;
        existing->alias = NULL;
        existing->addressType = NULL;
        existing->connected = FALSE;
        existing->trusted = FALSE;
        existing->paired = FALSE;
        existing->deviceclass = 0;
        existing->manufacturer = 0;
        existing->manufacturer_data_hash = 0;
        existing->appearance = 0;
        existing->uuids_length = 0;

        // RSSI values are stored with kalman filtering
        kalman_initialize(&existing->kalman);
        existing->last_value = 0;
        time(&existing->last_sent);
        time(&existing->last_rssi);

        existing->last_sent = existing->last_sent - 10000; // bump back in time so first RSSI goes straight through
        existing->last_rssi = existing->last_rssi - 10000; // bump back in time so first RSSI goes straight through

        kalman_initialize(&existing->kalman_interval);

        g_print("Added device %s\n", address);
    }
    else
    {
        // get value from hashtable
        existing = (struct Device *)g_hash_table_lookup(hash, address);
        //g_print("Existing value %s\n", existing->address);
        g_print("Existing device %s '%s'\n", address, existing->name);
    }


    // If after examining every key/value pair, distance has been set then we will send it
    bool send_distance = FALSE;

    const gchar *property_name;
    GVariantIter i;
    GVariant *prop_val;
    g_variant_iter_init(&i, properties); // no need to free this
    while (g_variant_iter_next(&i, "{&sv}", &property_name, &prop_val))
    {
        //bool isStringValue = g_variant_type_equal(g_variant_get_type(prop_val), G_VARIANT_TYPE_STRING);

        if (strcmp(property_name, "Address") == 0)
        {
            // do nothing, already picked off
        }
        else if (strcmp(property_name, "Name") == 0)
        {
            char *name = g_variant_dup_string(prop_val, NULL);

            // Trim whitespace (Bad Tracker device keeps flipping name)
            trim(name);

            if (g_strcmp0(existing->name, name) != 0)
            {
                g_print("  %s Name has changed '%s' -> '%s'  ", address, existing->name, name);
                send_to_mqtt_single(address, "name", name);
                if (existing->name != NULL)
                    g_free(existing->name);
                existing->name = name; // was strdup(name);
            }
        }
        else if (strcmp(property_name, "Alias") == 0)
        {
            char *alias = g_variant_dup_string(prop_val, NULL);

            trim(alias);

            if (g_strcmp0(existing->alias, alias) != 0)
            {
                g_print("  %s Alias has changed '%s' -> '%s'  ", address, existing->alias, alias);
                send_to_mqtt_single(address, "alias", alias);
            }
            if (existing->alias != NULL)
                g_free(existing->alias);
            existing->alias = alias;
        }
        else if (strcmp(property_name, "AddressType") == 0)
        {
            char *addressType = g_variant_dup_string(prop_val, NULL);

            // Compare values and send
            if (g_strcmp0(existing->addressType, addressType) != 0)
            {
                g_print("  %s Type has changed '%s' -> '%s'  ", address, existing->addressType, addressType);
                send_to_mqtt_single(address, "type", addressType);
                if (g_strcmp0("public", addressType) == 0) {
                  existing->addressType = "public";
                } else {
                  existing->addressType = "random";
                }
            }
            g_free(addressType);
        }
        else if (strcmp(property_name, "RSSI") == 0 && (changed == FALSE)) {
            int16_t rssi = g_variant_get_int16(prop_val);
            g_print("  %s RSSI repeat %i changed=%i\n", address, rssi, changed);
        }
        else if (strcmp(property_name, "RSSI") == 0)
        {
            int16_t rssi = g_variant_get_int16(prop_val);
            //send_to_mqtt_single_value(address, "rssi", rssi);

            //g_print("  %s RSSI has changed %i changed=%i\n", address, rssi, changed);

            time_t now;
            time(&now);

            // track gap between RSSI received events
            //double delta_time_received = difftime(now, existing->last_rssi);
            time(&existing->last_rssi);

            double delta_time_sent = difftime(now, existing->last_sent);

            // Smoothed delta time, interval between RSSI events
            //float current_time_estimate = (&existing->kalman_interval)->current_estimate;

            //bool tooLate = (current_time_estimate != -999) && (delta_time_received > 2.0 * current_time_estimate);

            //float average_delta_time = kalman_update(&existing->kalman_interval, (float)delta_time_sent);

            double N = 3.0;   // 2.0 to 4.0 depending on environment

            bool isBarn = access_point_address[5] == 0xa3;
            if (isBarn) {
              N = 2.8;        // no walls (2.5 gave 15m distances for 5m real
            }

            double OneMeterRSSI = -50.0; // Measured power

            //   1m =>  rssi == -50.0
            //  10m =>  30+50 == -rssi   -80dbM
            //  RSSI = -50   distance = 1.0m
            //  RSSI = -100  distance = 46m         which seems about right for outdoor, maybe N is less indoor?

            double exponent = ((OneMeterRSSI - (double)rssi) / (10.0 * N));

            double distance = pow(10.0, exponent);

            float averaged = kalman_update(&existing->kalman, distance);


            // 100s with RSSI change of 1 triggers send
            // 10s with RSSI change of 10 triggers send
            double delta_v = fabs(existing->last_value - averaged);
            double score =  delta_v * (delta_time_sent + 1.0);

 //           if (tooLate) {
 //               // Significant gap since last RSSI, this may be the 'dead letter' from controller
 //               g_print("Ignoring dead letter RSSI %s %.0fs > 2.0 * %.0fs\n", address, delta_time_received, average_delta_time);
 //               //send_to_mqtt_single_float(address, "rssi", -109.0);  // debug, dummy value
 //           }
 //           else
            if (changed && (score > THRESHOLD))